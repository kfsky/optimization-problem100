# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01graph.ipynb (unless otherwise specified).

__all__ = ['rnd_graph', 'rnd_adj', 'rnd_adj_fast', 'adjacent', 'to_nx_graph', 'to_plotly_fig', 'complement', 'shuffle',
           'read_gpp_graph', 'read_gpp_coords', 'read_graph', 'read_compl_graph', 'make_adj', 'bfs', 'WHITE', 'BLACK',
           'GRAY', 'INFINITY', 'NIL', 'make_inverse_adj', 'scc', '__get_super_parent']

# Cell
import random, math
import networkx as nx
import plotly.graph_objs as go
import plotly

# Cell
def rnd_graph(n, prob):
    """Make a random graph with 'n' nodes, and edges created between
    pairs of nodes with probability 'prob'.
    Returns a pair, consisting of the list of nodes and the list of edges.
    """
    nodes = list(range(n))
    edges = []
    for i in range(n - 1):
        for j in range(i + 1, n):
            if random.random() < prob:
                edges.append((i, j))
    return nodes, edges


def rnd_adj(n, prob):
    """Make a random graph with 'n' nodes and 'nedges' edges.
    return node list [nodes] and adjacency list (list of list) [adj]"""
    nodes = list(range(n))
    adj = [set([]) for i in nodes]
    for i in range(n - 1):
        for j in range(i + 1, n):
            if random.random() < prob:
                adj[i].add(j)
                adj[j].add(i)
    return nodes, adj


def rnd_adj_fast(n, prob):
    """Make a random graph with 'n' nodes, and edges created between
    pairs of nodes with probability 'prob', running in  O(n+m)
    [n is the number of nodes and m is the number of edges].
    Returns a pair, consisting of the list of nodes and the list of edges.
    """
    nodes = list(range(n))
    adj = [set([]) for i in nodes]

    if prob == 1:
        return nodes, [[j for j in nodes if j != i] for i in nodes]

    i = 1  # the first node index
    j = -1
    logp = math.log(1.0 - prob)  #

    while i < n:
        logr = math.log(1.0 - random.random())
        j += 1 + int(logr / logp)
        while j >= i and i < n:
            j -= i
            i += 1
        if i < n:  # else, graph is ready
            adj[i].add(j)
            adj[j].add(i)
    return nodes, adj


def adjacent(nodes, edges):
    """Determine the adjacent nodes on the graph."""
    adj = [set([]) for i in nodes]
    for (i, j) in edges:
        adj[i].add(j)
        adj[j].add(i)
    return adj

# Cell
def to_nx_graph(nodes, adj):
    G = nx.Graph()
    E = [(i, j) for i in nodes for j in adj[i]]
    G.add_edges_from(E)
    return G

# Cell
def to_plotly_fig(
    G,
    node_size=20,
    line_width=2,
    line_color="blue",
    text_size=20,
    colorscale="Rainbow",
    pos=None,
):

    node_x = []
    node_y = []
    if pos is None:
        pos = nx.spring_layout(G)
    color, text = [], []
    for v in G.nodes():
        x, y = pos[v][0], pos[v][1]
        color.append(G.nodes[v]["color"])
        text.append(v)
        node_x.append(x)
        node_y.append(y)

    node_trace = go.Scatter(
        x=node_x,
        y=node_y,
        mode="markers+text",
        hoverinfo="text",
        text=text,
        textposition="bottom center",
        textfont_size=text_size,
        marker=dict(
            showscale=True,
            # colorscale options
            #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
            #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
            #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
            colorscale=colorscale,
            reversescale=True,
            color=color,
            size=node_size,
            colorbar=dict(
                thickness=15, title="Node Color", xanchor="left", titleside="right"
            ),
            line_width=2,
        ),
    )

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.append(x0)
        edge_x.append(x1)
        edge_x.append(None)
        edge_y.append(y0)
        edge_y.append(y1)
        edge_y.append(None)

    edge_trace = go.Scatter(
        x=edge_x,
        y=edge_y,
        line=dict(width=line_width, color=line_color),
        hoverinfo="none",
        mode="lines",
    )

    layout = go.Layout(
        # title='Graph',
        titlefont_size=16,
        showlegend=False,
        hovermode="closest",
        margin=dict(b=20, l=5, r=5, t=40),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    )
    fig = go.Figure([node_trace, edge_trace], layout)

    return fig

# Cell
def complement(nodes, edges):
    """determine the complement of 'edges'"""
    compl = []
    edgeset = set(edges)
    for i in range(len(nodes) - 1):
        for j in range(i + 1, len(nodes)):
            if (i, j) not in edgeset:
                # assert (i,j) not in compl
                compl.append((i, j))
    return compl

def shuffle(nodes, adj):
    """randomize graph: exchange labels of two vertices, a number of times"""
    n = len(nodes)
    order = list(range(n))
    random.shuffle(order)

    newadj = [None for i in nodes]
    for i in range(n):
        newadj[order[i]] = [order[j] for j in adj[i]]
        newadj[order[i]].sort()
    return newadj


def read_gpp_graph(filename):
    """Read a file in the format specified by David Johnson for the DIMACS
    graph partitioning challenge.
    Instances are available at ftp://dimacs.rutgers.edu/pub/dsj/partition
    """
    try:
        if len(filename) > 3 and filename[-3:] == ".gz":  # file compressed with gzip
            import gzip

            f = gzip.open(filename, "rb")
        else:  # usual, uncompressed file
            f = open(filename)
    except IOError:
        print("could not open file", filename)
        exit(-1)

    lines = f.readlines()
    f.close()
    n = len(lines)
    nodes = list(range(n))
    edges = set([])
    adj = [[] for i in nodes]
    pos = [None for i in nodes]

    for i in nodes:
        lparen = lines[i].find("(")
        rparen = lines[i].find(")") + 1
        exec("x,y = %s" % lines[i][lparen:rparen])
        pos[i] = (x, y)
        paren = lines[i].find(")") + 1
        remain = lines[i][paren:].split()
        for j_ in remain[1:]:
            j = int(j_) - 1  # -1 for having nodes index starting on 0
            if j > i:
                edges.add((i, j))
            adj[i].append(j)
    for (i, j) in edges:
        assert i in adj[j] and j in adj[i]
    return nodes, adj


def read_gpp_coords(filename):
    """Read coordinates for a graph in the format specified by David Johnson
    for the DIMACS graph partitioning challenge.
    Instances are available at ftp://dimacs.rutgers.edu/pub/dsj/partition
    """
    try:
        if len(filename) > 3 and filename[-3:] == ".gz":  # file compressed with gzip
            import gzip

            f = gzip.open(filename, "rb")
        else:  # usual, uncompressed file
            f = open(filename)
    except IOError:
        print("could not open file", filename)
        exit(-1)

    lines = f.readlines()
    f.close()
    n = len(lines)
    nodes = list(range(n))
    pos = [None for i in nodes]
    for i in nodes:
        lparen = lines[i].find("(")
        rparen = lines[i].find(")") + 1
        exec("x,y = %s" % lines[i][lparen:rparen])
        pos[i] = (x, y)
    return pos


def read_graph(filename):
    """Read a graph from a file in the format specified by David Johnson
    for the DIMACS clique challenge.
    Instances are available at
    ftp://dimacs.rutgers.edu/pub/challenge/graph/benchmarks/clique
    """
    try:
        if len(filename) > 3 and filename[-3:] == ".gz":  # file compressed with gzip
            import gzip

            f = gzip.open(filename, "rb")
        else:  # usual, uncompressed file
            f = open(filename)
    except IOError:
        print("could not open file", filename)
        exit(-1)

    for line in f:
        if line[0] == "e":
            e, i, j = line.split()
            i, j = int(i) - 1, int(j) - 1  # -1 for having nodes index starting on 0
            adj[i].add(j)
            adj[j].add(i)
        elif line[0] == "c":
            continue
        elif line[0] == "p":
            p, name, n, nedges = line.split()
            # assert name == 'clq'
            n, nedges = int(n), int(nedges)
            nodes = list(range(n))
            adj = [set([]) for i in nodes]
    f.close()
    return nodes, adj


def read_compl_graph(filename):
    """Produce complementary graph with respect to the one define in a file,
    in the format specified by David Johnson for the DIMACS clique challenge.
    Instances are available at
    ftp://dimacs.rutgers.edu/pub/challenge/graph/benchmarks/clique
    """
    nodes, adj = read_graph(filename)
    nset = set(nodes)
    for i in nodes:
        adj[i] = nset - adj[i] - set([i])
    return nodes, adj

# Cell
def make_adj(V, E):
    """Create an adjacency list using V and E."""
    adj = {}
    for u in V:
        adj[u] = []
    for (u, v) in E:
        adj[u].append(v)
    return adj

# Cell
import sys

WHITE = 1
BLACK = 2
GRAY = WHITE + BLACK
INFINITY = sys.maxsize  # Python 3
NIL = None


def bfs(V, adj, s):
    color = {}
    d = {}
    p = {}
    for u in V:
        color[u] = WHITE
        d[u] = INFINITY
        p[u] = NIL
    color[s] = GRAY
    d[s] = 0
    Q = [s]
    while len(Q) != 0:
        u = Q[0]
        for v in adj[u]:
            if color[v] == WHITE:
                color[v] = GRAY
                d[v] = d[u] + 1
                p[v] = u
                Q.append(v)
        Q.remove(u)
        color[u] = BLACK
    return (d, p)

# Cell
def make_inverse_adj(V, E):
    """Create an inversed adjacenct list.
    That is, all edges (u,v) are recorded as (v,u).
    """
    adj = {i: [] for i in V}
    for (u, v) in E:
        adj[v].append(u)
    return adj


def scc(V, E):
    adj = make_adj(V, E)
    c = dfs(V, adj)
    iadj = make_inverse_adj(V, E)
    c = dfs(c.topo, iadj)  # c.topo provides the finish order in reverse.
    S = {}
    for u in V:
        v = __get_super_parent(u, c.p)
        if not (v in S):
            S[v] = []
        S[v].append(u)
    R = []
    for v in S:
        R.append(S[v])
    return R


def __get_super_parent(u, p):
    v = u
    while p[v] != NIL:
        v = p[v]
    return v